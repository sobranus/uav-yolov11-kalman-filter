"""
distance.py
Loads jsonl detection data generated by detection.py,
Estimate object detection distance using kalman filter from 2 axis measurement bounding box data.
"""

import numpy as np
import json
import matplotlib.pyplot as plt

# Adapt values to your system model
DETECTIONS_JSONL = "detections.jsonl"   # jsonl file of object detection
frames_start = 0                        # adapt to object detection frames
frames_end = 775                        # adapt to object detection frames
Q = 0.001                               # process noise
x = 0.0                                 # initial estimate
P = 1.0                                 # initial uncertainty
focal_length_w = 2000
focal_length_h = 1125
real_size_w = 20
real_size_h = 25
distances_w = []
distances_h = []


def calculate_distance(detections, frame_index, focal_length, real_size, axis='w'):
    for det in detections:
        bbox = det.get("bbox_xyxy", [])
        if len(bbox) == 4:
            x1, y1, x2, y2 = bbox
            if axis == 'h':
                px_size = y2 - y1
            else:
                px_size = x2 - x1
            distance = (real_size * focal_length / px_size) / 100
            print(f"Frame {frame_index}: distance = {distance:.2f} meters")
            return distance
        
        
def kf(z1, z2, R1, R2):
    # Kalman filter parameters
    # z1 = measurement 1 model
    # z2 = measurement 2 model
    
    global Q, x, P
    estimates = []
    
    n = len(z1)

    for i in range(n):
        x_pred = x
        P_pred = P + Q

        # --- Update with sensor 1 ---
        K1 = P_pred / (P_pred + R1)
        x_upd1 = x_pred + K1 * (z1[i] - x_pred)
        P_upd1 = (1 - K1) * P_pred

        # --- Update with sensor 2 ---
        K2 = P_upd1 / (P_upd1 + R2)
        x_upd2 = x_upd1 + K2 * (z2[i] - x_upd1)
        P_upd2 = (1 - K2) * P_upd1

        # Save results
        x, P = x_upd2, P_upd2
        estimates.append(x)

    return estimates


def main():
    with open(DETECTIONS_JSONL, "r") as f:
        for line in f:
            if not line.strip():
                continue

            data = json.loads(line)
            frame_index = data.get("frame_index")
            detections = data.get("detections", [])
            
            if (not detections) or frame_index < frames_start:
                continue
            
            distances_w.append(calculate_distance(detections, frame_index, focal_length_w, real_size_w, axis='w'))
            distances_h.append(calculate_distance(detections, frame_index, focal_length_h, real_size_h, axis='h'))
            if frame_index >= frames_end:
                frames = np.arange(1, len(distances_w) + 1)

                # Compute first derivative (velocity estimate)
                v1 = np.diff(distances_w)
                v2 = np.diff(distances_h)

                # Noise is the random high-frequency part; 
                # estimate it from difference of consecutive velocities:
                accel_like1 = np.diff(v1)
                accel_like2 = np.diff(v2)

                R_est1 = np.var(accel_like1)
                R_est2 = np.var(accel_like2)
                print("Estimated W measurement noise variance:", R_est1)
                print("Estimated H measurement noise variance:", R_est2)
                
                estimates = kf(distances_w, distances_h, R_est1, R_est2)


                plt.figure(figsize=(10, 5))
                plt.plot(frames, estimates, color='black', linewidth=0.8)
                plt.plot(frames, distances_w, color='red', linewidth=0.5)
                plt.plot(frames, distances_h, color='blue', linewidth=0.5)
                plt.title("Object Distance Over Time")
                plt.xlabel("Frame steps")
                plt.ylabel("Distance (m)")
                plt.grid(True)
                plt.tight_layout()
                plt.show()
                
                return
                

if __name__ == "__main__":
    main()
