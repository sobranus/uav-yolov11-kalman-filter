"""
position.py
Loads jsonl detection data generated by detection.py,
Estimate object detection distance using kalman filter from 2 axis measurement bounding box data.
"""

import numpy as np
import json
import matplotlib.pyplot as plt

DETECTIONS_R = "detections_mavic_r.jsonl"       # jsonl file of 1st perspective object detection
DETECTIONS_L = "detections_mavic_l.jsonl"       # jsonl file of 2nd perspective object detection

# --- Camera parameters ---
fx, fy = 800.0, 800.0       # camera's focal length
cx, cy = 432.0, 240.0       # camera/frame centroid
baseline = 2.0              # meters

# Only field position (3rd axis/altitude is not included)
K = np.array([[fx, 0, cx],
              [0, fy, cy],
              [0, 0, 1]])

# Camera 1 (left) at origin
R1 = np.eye(3)
t1 = np.zeros((3,1))

# Camera 2 (right) shifted along x-axis
R2 = np.eye(3)
t2 = np.array([[-baseline, 0, 0]]).T
P1 = K @ np.hstack((R1, t1))
P2 = K @ np.hstack((R2, t2))

estimated_pos = []
estimated_pos_n = []


def triangulate_linear(P1, P2, x1, x2):
    """Triangulate a 3D point using SVD."""
    A = np.zeros((4, 4))
    u1, v1 = x1
    u2, v2 = x2
    A[0] = u1 * P1[2] - P1[0]
    A[1] = v1 * P1[2] - P1[1]
    A[2] = u2 * P2[2] - P2[0]
    A[3] = v2 * P2[2] - P2[1]
    _, _, Vt = np.linalg.svd(A)
    X = Vt[-1]
    return X[:3] / X[3]


def kf(z1, z2):
    # Kalman filter parameters
    # z1 = sensor 1 model
    # z2 = sensor 2 model
    
    z1 = np.array(z1)
    z2 = np.array(z2)
    n = min(len(z1), len(z2))
    
    Q = np.eye(2) * 0.001    # process noise
    x = np.zeros((2, 1))     # initial estimate
    P = np.eye(2) * 1.0      # initial uncertainty
    R1 = np.eye(2) * 0.01
    R2 = np.eye(2) * 0.005

    estimates = []
    
    for i in range(n):
        # --- Prediction ---
        x_pred = x
        P_pred = P + Q

        # --- Update with sensor 1 ---
        K1 = P_pred @ np.linalg.inv(P_pred + R1)
        x_upd1 = x_pred + K1 @ (z1[i].reshape(2, 1) - x_pred)
        P_upd1 = (np.eye(2) - K1) @ P_pred

        # --- Update with sensor 2 ---
        K2 = P_upd1 @ np.linalg.inv(P_upd1 + R2)
        x_upd2 = x_upd1 + K2 @ (z2[i].reshape(2, 1) - x_upd1)
        P_upd2 = (np.eye(2) - K2) @ P_upd1

        # Save results
        x, P = x_upd2, P_upd2
        estimates.append(x.flatten())

    return np.array(estimates)


def main():
    with open(DETECTIONS_R, "r", encoding="utf-8") as f1, open(DETECTIONS_L, "r", encoding="utf-8") as f2:
        data_r = [json.loads(line) for line in f1 if line.strip()]
        data_l= [json.loads(line) for line in f2 if line.strip()]
        
    for i in range(min(len(data_r), len(data_l))):
        frame1 = data_r[i]
        frame2 = data_l[i]
        det_r = frame1.get("detections")
        det_l = frame2.get("detections")

        if not det_r or not det_l:
            print(f"⚠️ Skipping frame {i} (index {frame1.get('frame_index', i)}): empty detections in one or both files")
            continue

        bbox_r = det_r[0]["bbox_xyxy"]
        bbox_l = det_l[0]["bbox_xyxy"]
        x1r, y1r, x2r, y2r = bbox_r
        x1l, y1l, x2l, y2l = bbox_l
        
        # Project to images
        x1 = [(x1r + x2r) / 2, (y1r + y2r) / 2]
        x2 = [(x1l + x2l) / 2, (y1l + y2l) / 2]

        # Triangulate
        X_est = triangulate_linear(P1, P2, x1, x2)

        # Take only ground-plane (X, Z)
        ground_pos = X_est[[0, 2]]

        print("\nEstimated 2D ground position (X,Z) in meters:", ground_pos)

        # Optional pixel noise to simulate detection error
        noise_std = 0.5
        x1_n = x1 + np.random.normal(scale=noise_std, size=2)
        x2_n = x2 + np.random.normal(scale=noise_std, size=2)
        X_est_n = triangulate_linear(P1, P2, x1_n, x2_n)
        ground_pos_n = X_est_n[[0, 2]]
        print("Estimated ground position (X,Z):", ground_pos_n)
        
        estimated_pos.append(ground_pos)
        estimated_pos_n.append(ground_pos_n)
    
    # del estimated_pos[0:50]
    # del estimated_pos_n[0:50]
    z1 = np.array(estimated_pos)
    z2 = np.array(estimated_pos_n)
        
    estimates = kf(estimated_pos, estimated_pos_n)
    frames = np.arange(len(estimates))

    # Plot
    plt.figure(figsize=(20, 6))
    
    plt.subplot(1, 2, 1)
    plt.plot(frames, z1[:, 0], 'r--', label='Sensor 1 X', linewidth=0.5)
    plt.plot(frames, z2[:, 0], 'b--', label='Sensor 2 X', linewidth=0.5)
    plt.plot(frames, estimates[:, 0], 'k-', label='Kalman X', linewidth=0.8)
    plt.ylim(2, 3)
    plt.title('X Position')
    plt.xlabel('Time step')
    plt.ylabel('X')
    plt.legend()
    plt.grid(True)
    
    # Plot Y positions
    plt.subplot(1, 2, 2)
    plt.plot(frames, z1[:, 1], 'r--', label='Sensor 1 Y', linewidth=0.5)
    plt.plot(frames, z2[:, 1], 'b--', label='Sensor 2 Y', linewidth=0.5)
    plt.plot(frames, estimates[:, 1], 'k-', label='Kalman Y', linewidth=0.8)
    plt.title('Y Position')
    plt.xlabel('Time step')
    plt.ylabel('Y')
    plt.legend()
    plt.grid(True)

    plt.tight_layout()
    plt.show()
    
    return
                

if __name__ == "__main__":
    main()